docker images # списов скаченных образов
docker ps # список всех запущенных контейнеров
docker ps -a # список вообще всех контейнеров, в том числе и остановленных
docker run -it (-d в фоновом режиме) debian # создание и запуск контейнера с debian в интерактивном режиме
docker exec -it <container_id> bash # Запуск bash в уже запущенном контейнере. Exec в ключем -it выполняет команду внутри уже запущенного контейнера. Без ключа -it команда будет выполнена в контейнере, а ее вывод мы получим в текущую консоль
docker start -ai <container_id> # Запускает выключенный контейнер в интерактивном режиме
docker inspect <container_id> # Получить информацию о контейнере

docker rm <container_id> # Удалить остановленный контейнер
docker rmi <container_id> # Удалить образ

docker build [-t] [-f] context # создание образа из докер-файла. -t название образа. -f путь до докер-файла.
docker build -t echo_server_image 

Bind mounts - проброс общей папки между хостом и контейнером

docker run -v {HOST_DIR}:{CONTAINER_DIR} image # указывается абсолютный путь до папки

Volumes - механизм постоянного хранения данных созданных и используемых контейнерами. Как бы одно
хранилище которое могут использовать разные контейнеры

docker run -v {CONTAINER_DIR} image # создает анонимный Volume в контейнере
 

____

ДИРЕКТИВЫ Dockerfile

CMD - запускает заданную инструкцию во время инициализации контейнера. Если указать какую то другую команду в конце, 
то она полностью переопределяется при запуске контейнера. 

ENTRYPOINT - определяет выполняемый файл запускаемый при инициализации контейнера. Если при запуске
конетейнера указать еще какие-то команды, то они будут являтся утилитами для того что указано в ENTRYPOINT.
Например ENTRYPOINT=pytest. При запуске указат -s -v получим в итоге: pytest -s -v

EXPOSE - сообщает Docker engine о том, что в данном контейнере будет существоват процесс,
прослушивающий заданный порт или несколько портов. При запуске контейнера нужно указать маппинг портов:
docker run -p {HOST_PORT}:{CONTAINER_PORT} image
